---
apply: 常に使用する
---

# Java ルール

## ドキュメント概要

このドキュメントは、`Java` に関するルールが記載されています。

## 基本方針

- 既存コードの設計・流儀を最優先し、勝手な大改造はしない（最小変更で目的達成）。
- 不明点（仕様・入出力・例外方針・トランザクション境界・性能要件・セキュリティ要件）が結果に影響する場合は先に確認質問をする。
- 可能なら **意図（Why）→変更点（What）→手順（How）** の順で説明する。

## Spring Boot のレイヤリング規約（最重要）

- Controller: HTTP（リクエスト/レスポンス、バリデーション、ステータスコード、DTO変換）に専念。業務ロジック・永続化は置かない。
- Service: 業務ロジックの中心。トランザクション境界を持つ（必要時 `@Transactional`）。
- Repository: 永続化（Spring Data JPA）。クエリ・ロック・取得戦略を責務にする。業務判断はしない。
- Entity: 永続化モデル。Controller の入出力として直接使わない（DTOを使う）。
- DTO: API境界用。入力DTOと出力DTOは分ける（必要時）。

## DI（依存性注入）

- 原則 **コンストラクタ注入**（`final` フィールド + 必要なら Lombok `@RequiredArgsConstructor`）。
- `@Autowired` のフィールド注入は避ける（テストしにくく、循環参照に気づきにくい）。
- Bean は過剰に増やさず、責務のまとまりを優先。

## トランザクション（Spring @Transactional）

- 既定: 変更系は `@Transactional`、参照系は必要に応じて `@Transactional(readOnly = true)`。
- `@Transactional` は基本 Service 層に付ける（RepositoryやControllerに付けるのは例外）。
- 「どこまでが一貫性単位か」を意識し、複数Repository操作は同一Txにまとめる。
- Lazyロード前提の設計でControllerからEntityを触らない（Lazy例外の温床）。必要ならService内でDTOへ詰め替える。

## Controller / API 設計

- 入力は `@RequestBody` + `@Valid`（Bean Validation）を基本とする。
- ステータスコードを明確化:
    - 作成: 201
    - 更新: 200/204
    - 削除: 204
    - バリデーション: 400
    - 認可/認証: 401/403
    - 参照失敗: 404
    - 競合: 409
- `ResponseEntity` は「ヘッダ/ステータス制御が必要なとき」に使い、不要なら素直に戻り値で返す。
- API境界では Entity を返さない（循環参照、Lazy、内部構造露出のリスク）。

## バリデーション（Bean Validation）

- DTO に制約を付与し、Controllerで `@Valid` を適用。
- 業務ルール（例: 「開始日 < 終了日」）は Service でチェックし、ドメイン例外にする。
- バリデーションエラーのレスポンス形式は統一する（後述の例外ハンドリングでまとめる）。

## 例外設計と例外ハンドリング

- 例外の握りつぶし禁止。必要なら「補足→文脈を付けて再送出」。
- 技術例外（DB等）をそのままControllerに漏らさず、意味のある例外へ変換するか、共通ハンドラで整形する。
- 原則 `@RestControllerAdvice` で例外→HTTPレスポンスを一元管理する（メッセージの統一、ログの統一）。
- 例外メッセージに機密情報（資格情報、トークン、内部URLなど）を含めない。
- 例外メッセージは `messages.properties` で一元管理する。

## JPA / Hibernate（Spring Data JPA）

- N+1 を意識する。必要なら `@EntityGraph`、fetch join、クエリ最適化を検討。
- `equals/hashCode` はEntityで安易に実装しない（ID採番前後で破綻しやすい）。必要なら方針を明確化してから。
- 大量更新はループsave連発より、バルク更新やバッチを検討（要件があるときだけ）。
- リポジトリメソッド命名は読みやすく。複雑なら `@Query` を使う。

## 設定（application.properties / YAML）と秘密情報

- 資格情報・秘密情報はコードやサンプル出力に載せない（必ずプレースホルダにする）。
- 可能なら環境変数やプロファイルで切り替える前提で提案する（dev/test/prod）。
- ログに設定値（特に秘密情報）を出さない。

## ロギング

- ログレベルを適切に（DEBUG/INFO/WARN/ERROR）。例外は必要な箇所で1回だけ適切にログする（二重ログを避ける）。
- リクエストボディ等は無闇にログしない（PIIや秘密情報が混ざりやすい）。
- 監査が必要なら「何を」「誰が」「いつ」を最小限で記録する設計を提案する。

## テスト（未定前提のルール）

- テスト追加の提案時は、まず目的を確認し以下から選ぶ:
    - 単体テスト: Service中心（Mockito等）
    - スライステスト: `@WebMvcTest` / `@DataJpaTest`
    - 結合テスト: `@SpringBootTest`
- まだ方針がない場合は、まず Service の単体テスト or `@WebMvcTest` から提案し、依存の重さを抑える。
- テストデータは読みやすさ優先（Factory/Builderを提案可）。

## コメント
- 日本語
- クラス・メソッドは `JavaDoc` でコメントを付与

## 出力ルール（AIの振る舞い）

- 変更提案は「目的」「変更点」「注意点（破壊的変更の有無）」を短く書く。
- コード提示はコンパイル可能な単位で。部分変更なら前後文脈を付ける。
- 不確かな推測は断定しない（「〜の可能性」「確認したい」）。